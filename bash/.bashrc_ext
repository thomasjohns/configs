# bashrc extensions
# Source this file from your main ~/.bashrc:
#   if [ -f ~/.bashrc_ext ]; then . ~/.bashrc_ext; fi

# --- Aliases ---
alias l='eza'
alias la='eza -a'
alias ll='eza -lah'
alias ls='eza --color=auto'
alias j='just'
alias k='kubectl'
alias gc='gcloud'

# --- Environment Variables ---
export EDITOR=nvim
export VISUAL=nvim

# --- PATH additions ---

# --- Prompt ---

# --- Functions ---

# nvim on changed files from git status
nvim-changed() {
    git status --porcelain | rg ' M ' | sd ' M ' '' | xargs nvim;
}

last-status() {
    echo $?;
}

git-branch-prune() {
    git branch --merged | grep -v '^\*' | grep -v 'main$' | grep -v 'master$' | xargs git branch -d
}

wt() {
    if [ -z "$1" ]; then
        echo "Usage: wt <worktree-name>"
        return 1
    fi

    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: not inside a git repository"
        return 1
    fi

    # Detect bare repo even when cd'd into one of its worktrees
    local git_common_dir
    git_common_dir="$(cd "$(git rev-parse --git-common-dir)" && pwd)"
    local is_bare
    is_bare="$(git config -f "$git_common_dir/config" --get core.bare 2>/dev/null)"

    if [ "$is_bare" = "true" ]; then
        _wt_bare "$1" "$git_common_dir"
    else
        _wt_normal "$1"
    fi
}

_wt_normal() {
    local name="$1"
    local repo_root
    repo_root="$(git rev-parse --show-toplevel)"

    local wt_path="$repo_root/$name"

    git worktree add "$wt_path" 2>/dev/null
    if [ $? -ne 0 ]; then
        echo "Error: failed to create worktree '$name'"
        return 1
    fi

    # Exclude the worktree directory from the outer repo's tracking
    local exclude_file="$repo_root/.git/info/exclude"
    if ! grep -qxF "$name" "$exclude_file" 2>/dev/null; then
        echo "$name" >> "$exclude_file"
    fi

    # Copy gitignored files to the new worktree
    local ignored_files
    ignored_files="$(git -C "$repo_root" ls-files --others --ignored --exclude-standard)"
    if [ -n "$ignored_files" ]; then
        echo "$ignored_files" | rsync -a --files-from=- "$repo_root/" "$wt_path/"
    fi

    echo "Worktree '$name' created at $wt_path"
}

_wt_bare() {
    local name="$1"
    local bare_root="$2"

    # Resolve the actual default branch name from HEAD
    local default_branch
    default_branch="$(git -C "$bare_root" symbolic-ref --short HEAD 2>/dev/null)"

    # If user typed "main" or "master", use the actual default branch name
    if [ "$name" = "main" ] || [ "$name" = "master" ]; then
        if [ -n "$default_branch" ] && [ "$name" != "$default_branch" ]; then
            echo "Note: default branch is '$default_branch', using that instead of '$name'"
            name="$default_branch"
        fi
    fi

    local wt_path="$bare_root/$name"

    git worktree add "$wt_path" 2>/dev/null
    if [ $? -ne 0 ]; then
        echo "Error: failed to create worktree '$name'"
        return 1
    fi

    # For non-default-branch worktrees, copy gitignored files from the primary worktree
    if [ "$name" != "$default_branch" ]; then
        local primary_wt=""
        if [ -n "$default_branch" ] && [ -d "$bare_root/$default_branch" ]; then
            primary_wt="$bare_root/$default_branch"
        fi

        if [ -n "$primary_wt" ]; then
            local ignored_files
            ignored_files="$(git -C "$primary_wt" ls-files --others --ignored --exclude-standard)"
            if [ -n "$ignored_files" ]; then
                echo "$ignored_files" | rsync -a --files-from=- "$primary_wt/" "$wt_path/"
            fi
        else
            echo "Warning: no '$default_branch' worktree found to copy gitignored files from"
        fi
    fi

    echo "Worktree '$name' created at $wt_path"
}
